@page "/web-rtc"
@rendermode InteractiveServer
@using System.Text.Json
@inject IJSRuntime JSRuntime

<PageTitle>WebRTC</PageTitle>

<h1>WebRTC</h1>

<MudGrid>    
    <MudItem xs="6">
        <MudPaper Class="d-flex align-center justify-center mud-width-full py-8">
            <video id="remoteVideo" autoplay style="width: 100%; border-radius: 8px;"></video>            
        </MudPaper>
    </MudItem>
    <MudItem xs="6">
        <MudPaper Class="d-flex align-center justify-center mud-width-full py-8">
            <video id="localVideo" autoplay muted style="width: 20%; border-radius: 8px;"></video>
        </MudPaper>
    </MudItem>
   
    <MudItem xs="12">
        
            <MudStack>
                <MudPaper Class="pa-3">
                    <MudText Typo="Typo.subtitle1" Class="mt-4">오디오바</MudText>
                    <MudProgressLinear Value="@AudioLevel" Class="mt-2" />
                </MudPaper>
                <MudPaper Class="pa-3">
                    <MudText Typo="Typo.subtitle1" Class="mt-4">마이크 볼륨 조절</MudText>
                    <MudSlider @bind-Value="MicrophoneVolume" Min="0" Max="100" Step="1" Class="mt-2" />
                </MudPaper>
                <MudPaper Class="pa-3">
                    <MudButton OnClick="StartWebRTC" Class="mt-4">
                        Start WebRTC
                    </MudButton>
                </MudPaper>
            </MudStack>
        
    </MudItem>

</MudGrid>

@code {

    private double AudioLevel { get; set; } = 0;
    private double MicrophoneVolume { get; set; } = 10; // 초기 볼륨 값

    private async Task StartWebRTC()
    {
        var dotNetRef = DotNetObjectReference.Create(this);
        await JSRuntime.InvokeVoidAsync("startWebRTC", "localVideo", "remoteVideo", dotNetRef);
    }


    [JSInvokable]
    public async Task SendAudioData(string audioDataJson)
    {
        try
        {
            // Parse JSON data
            var data = JsonSerializer.Deserialize<Dictionary<string, object>>(audioDataJson);
            if (data != null && data.ContainsKey("volume") && data.ContainsKey("audioData"))
            {
                // Validate volume
                if (data["volume"] is JsonElement volumeElement && volumeElement.TryGetDouble(out var volume))
                {
                    // Validate audioData
                    if (data["audioData"] is JsonElement audioDataElement && audioDataElement.ValueKind == JsonValueKind.Array)
                    {
                        var audioBytes = audioDataElement.EnumerateArray().Select(x => (byte)x.GetInt32()).ToArray();
                        // Update UI with volume
                        AudioLevel = Math.Clamp(volume, 0, 100);
                        StateHasChanged();
                        // Debugging output
                        //Console.WriteLine($"Valid audio data received. Volume: {volume}, Data size: {audioBytes.Length} bytes");
                        // Send audio data to SignalR server (if needed)
                        // await HubContext.Clients.All.SendAsync("SendAudioData", audioBytes);
                    }
                    else
                    {
                        Console.WriteLine("Invalid audioData format.");
                    }
                }
                else
                {
                    Console.WriteLine("Invalid volume format.");
                }
            }
            else
            {
                Console.WriteLine("Invalid audio data structure.");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error in SendAudioData: {ex.Message}");
        }
    }

    private async Task UpdateMicrophoneVolume()
    {
        await JSRuntime.InvokeVoidAsync("setMicrophoneVolume", MicrophoneVolume);
    }

}
